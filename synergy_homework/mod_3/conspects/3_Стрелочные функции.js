/*
    Стрелочные функции в ES6 представляют собой сокращенную форму записи функций,
    которые упрощают код и уменьшают объем. Они отличаются от обычных функций в том,
    что у них нет своего собственного контекста выполнения, что позволяет избежать ошибок,
    связанных с изменением значений this и arguments. Кроме того, они более короткие,
    что облегчает чтение и написание кода.

    Стрелочные функции объявляются с помощью =>. Например:
 */

// Обычная функция
function sum(a, b) {
    return a + b;
}

// Стрелочная функция
const sum = (a, b) => {
    return a + b
};

// краткий вид стрелочной функции
const sum = (a, b) => a + b;


// Пример: Стрелочная функция с несколькими аргументами
const sum = (a, b) => a + b;

console.log(sum(2, 3)); // Выведет: 5

/*
    Синтаксис стрелочных функций может быть более или менее сложным в зависимости от того,
    как они используются в коде. В этом материале мы рассмотрим несколько примеров кода,
    чтобы проиллюстрировать различные способы использования стрелочных функций в JavaScript ES6.

    Пример: Простая стрелочная функция
 */

// Обычная функция
function hello(name) {
    return `Hello, ${name}!`;
}

// Стрелочная функция
const hello = name => `Hello, ${name}!`;

console.log(hello('John')); // Выведет: "Hello, John!"


// Пример: Стрелочная функция внутри метода объекта


const user = {
    name: 'John',
    age: 30,
    sayHello: function() {
        console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
    },
    sayBye: () => {
        console.log(`Bye, my name is ${this.name} and I'm ${this.age} years old.`);
    }
};

user.sayHello(); // Выведет: "Hello, my name is John and I'm 30 years old."
user.sayBye(); // Выведет: "Bye, my name is undefined and I'm undefined years old."

/*
    В данном примере обычная функция sayHello корректно использует this для получения свойств name и age объекта user.
    Однако стрелочная функция sayBye не имеет своего собственного контекста выполнения и поэтому не может получить доступ к свойствам name и age.
 */

/*
    Стрелочная функция может иметь несколько аргументов, которые указываются в скобках.
    Если аргументов несколько, то они разделяются запятыми.

    Пример: Стрелочная функция с блоком
 */


// Обычная функция
function sum(a, b) {
    const result = a + b;
    return result;
}

// Стрелочная функция
const sum = (a, b) => {
    const result = a + b;
    return result;
};

console.log(sum(2, 3)); // Выведет: 5


/*

    В этом примере мы показываем, как использовать блок в стрелочной функции для выполнения нескольких операций.
    Блок должен заключаться в фигурные скобки, а любые операции, которые мы хотим выполнить,
    должны находиться внутри блока.

    Пример: Стрелочная функция внутри функции (callback)
 */

function outer() {
    const inner = (name) => {
        console.log(`Hello, ${name}!`);
    };

    inner('John');
}

outer(); // Выведет: "Hello, John!"

// Пример: Использование стрелочных функций вместо функций обратного вызова

const names = ['John', 'Bob', 'Alice'];

// Обычная функция обратного вызова
names.forEach(function(name) {
    console.log(`Hello, ${name}!`);
});

// Стрелочная функция обратного вызова
names.forEach(name => console.log(`Hello, ${name}!`));

/*

В этом примере мы показываем, как можно использовать стрелочные функции вместо функций обратного вызова.

Вместо того, чтобы определять функцию обратного вызова в отдельности, мы передаем стрелочную функцию в метод `forEach`.
Это уменьшает объем кода и делает его более читабельным.

Заключение

Стрелочные функции в JavaScript ES6 являются мощным инструментом для написания более чистого и понятного кода.

Итоги
    Стрелочные функции - это новая возможность в JavaScript ES6, которая позволяет определять функции более коротко и удобно.

    Стрелочные функции не имеют своего собственного контекста this, они используют контекст, в котором они были определены.

    Стрелочные функции могут быть использованы как анонимные функции или присвоены переменной.

    Стрелочные функции могут принимать аргументы, которые разделяются запятыми, и могут использоваться для выполнения нескольких операций с помощью блока.

    Стрелочные функции могут быть использованы внутри других функций и вместо функций обратного вызова.
 */

//________________________________________________________________________________________________________________________
//________________________________________________________________________________________________________________________
//________________________________________________________________________________________________________________________
/*
    домашнее задание

    Задача 1: Функция для подсчета суммы чисел
    Напишите функцию sum, которая принимает два числа и возвращает их сумму.
 */

const sum = (a, b) => {
    return a + b;
};

console.log(sum(2, 3)); // 5

/*
    В этом примере мы используем стрелочную функцию,
    чтобы определить функцию sum. Мы передаем два числа a и b в качестве аргументов,
    и затем возвращаем их сумму.

    Задача 2: Функция для проверки четности числа
    Напишите функцию isEven, которая принимает число и возвращает true,
    если число четное, и false, если число нечетное.
 */

const isEven = num => num % 2 === 0;

console.log(isEven(2)); // true
console.log(isEven(3)); // false

/*
    В этом примере мы используем стрелочную функцию, чтобы определить функцию isEven.
    Мы передаем число num в качестве аргумента, и затем проверяем, делится ли это число на 2 без остатка. Если да,
    то мы возвращаем true, в противном случае - false.

    Задача 3: Функция для поиска максимального числа в массиве
    Напишите функцию findMax, которая принимает массив чисел и возвращает максимальное число в этом массиве.
 */

const findMax = arr => {
    let max = arr[0];
    arr.forEach(num => {
        if (num > max) {
            max = num;
        }
    });
    return max;
};

console.log(findMax([1, 2, 3, 4, 5])); // 5
console.log(findMax([-1, -2, -3, -4, -5])); // -1

/*
    В этом примере мы используем стрелочную функцию, чтобы определить функцию findMax.
    Мы передаем массив arr в качестве аргумента, и затем итерируемся по массиву, используя метод forEach,
    чтобы найти максимальное число в массиве. Мы инициализируем переменную max с первым элементом массива arr[0],
    а затем сравниваем каждый элемент массива с max и обновляем max, если элемент больше max. В конце мы возвращаем max.

    Задача 4: Функция для фильтрации чисел
    Напишите функцию filterNumbers, которая принимает массив чисел и возвращает новый массив, содержащий только положительные числа.


 */
    const filterNumbers = arr => arr.filter(num => num > 0);

    console.log(filterNumbers([-1, 2, -3, 4, -5])); // [2, 4]
    console.log(filterNumbers([0, 1, 2, 3])); // [1, 2, 3]

/*
    Здесь мы определяем функцию filterNumbers, которая принимает массив arr в качестве аргумента и
    использует метод filter() для фильтрации чисел в массиве. Метод filter() вызывает функцию обратного вызова,
    которая принимает текущий элемент массива в качестве аргумента и возвращает true, если элемент должен быть сохранен, и false,
    если элемент должен быть исключен.

    В данном случае мы определяем функцию обратного вызова с помощью стрелочной функции, которая проверяет,
    является ли текущий элемент массива положительным числом (больше нуля). Если да, то функция возвращает true,
    и этот элемент сохраняется в новом массиве, который возвращается методом filter(). Если элемент отрицательный или равен нулю,
    функция возвращает false, и элемент исключается из нового массива.

    Затем мы вызываем функцию filterNumbers с несколькими примерами массивов чисел в качестве аргументов и выводим результаты с
    помощью console.log(). В первом примере мы передаем массив [-1, 2, -3, 4, -5] и ожидаем получить массив [2, 4],
    так как только положительные числа должны быть включены в результат. Во втором примере мы передаем массив [0, 1, 2, 3] и
    ожидаем получить массив [1, 2, 3], так как ноль не является положительным числом.
 */