/*
    Promises - это способ обработки асинхронного кода в JavaScript.
    Они представляют собой абстракцию, позволяющую выполнить операцию, которая может занять некоторое время,
    и ожидать ее завершения, прежде чем продолжить работу.

    Promises имеют три состояния:

        -ожидание (pending)
        -выполнено (fulfilled)
        -отклонено (rejected)



    Когда promise находится в состоянии ожидания, он еще не завершен.
    Когда promise переходит в состояние выполнено, он успешно завершается и возвращает значение.
    Когда promise переходит в состояние отклонено, он завершается с ошибкой и возвращает ошибку.

    Создание promise
    Прежде чем мы начнем использовать promises, нам нужно создать их.
    Для этого мы можем использовать конструктор Promise.
 */

const promise = new Promise((resolve, reject) => {
    // здесь находится асинхронный код
    // если он выполнится успешно, вызываем resolve с результатом
    // если он завершится с ошибкой, вызываем reject с ошибкой
});

/*
    Загрузка данных с сервера с помощью promises
    В этом примере мы будем использовать promises для загрузки данных с сервера.
 */

// Создаем promise для загрузки данных с сервера
const getData = () => {
    return new Promise((resolve, reject) => {
        // Создаем новый объект XMLHttpRequest
        const xhr = new XMLHttpRequest();

        // Устанавливаем обработчик для успешного завершения запроса
        xhr.onload = () => {
            if (xhr.status === 200) {
                // Возвращаем результат в состоянии fulfilled
                resolve(xhr.responseText);
            } else {
                // Возвращаем ошибку в состоянии rejected
                reject(new Error("Ошибка загрузки данных"));
            }
        };

        // Устанавливаем обработчик для ошибки запроса
        xhr.onerror = () => {
            reject(new Error("Ошибка сети"));
        };

        // Отправляем запрос на сервер
        xhr.open("GET", "/data");
        xhr.send();
    });
};

// Используем promise для загрузки данных и вывода их на экран
getData()
    .then((data) => {
        console.log(data);
    })
    .catch((error) => {
        console.error(error);
    });

//___________________________________________________________________________________________________________________

/*
    Комбинирование promises
    В этом примере мы будем использовать promises для комбинирования нескольких асинхронных операций.
 */

// Создаем promise для загрузки данных с сервера
const getData = () => {
    return new Promise((resolve, reject) => {
        // Создаем новый объект XMLHttpRequest
        const xhr = new XMLHttpRequest();

        // Устанавливаем обработчик для успешного завершения запроса
        xhr.onload = () => {
            if (xhr.status === 200) {
                // Возвращаем результат в состоянии fulfilled
                resolve(xhr.responseText);
            } else {
                // Возвращаем ошибку в состоянии rejected
                reject(new Error("Ошибка загрузки данных"));
            }
        };

        // Устанавливаем обработчик для ошибки запроса
        xhr.onerror = () => {
            reject(new Error("Ошибка сети"));
        };

        // Отправляем запрос на сервер
        xhr.open("GET", "/data");
        xhr.send();
    });
};

// Создаем promise для обработки данных
const processData = (data) => {
    return new Promise((resolve, reject) => {
        // Обрабатываем данные асинхронно
        setTimeout(() => {
            const processedData = data.toUpperCase();
            // Возвращаем обработанные данные в состоянии fulfilled
            resolve(processedData);
        }, 2000);
    });
};

// Используем promises для загрузки и обработки данных, а затем выводим их на экран
getData()
    .then((data) => {
        return processData(data);
    })
    .then((processedData) => {
        console.log(processedData);
    })
    .catch((error) => {
        console.error(error);
    });

/*
    В этом примере мы создаем два promises: один для загрузки данных с сервера,
    а другой - для обработки данных. Затем мы используем метод then для комбинирования promises:
    сначала мы загружаем данные с сервера, затем обрабатываем их и выводим на экран.
    Если происходит ошибка при загрузке или обработке данных, мы обрабатываем ее с помощью метода catch.

//___________________________________________________________________________________________________________________

    Promise.all
    В этом примере мы будем использовать Promise.all для одновременной загрузки нескольких независимых данных с сервера.
 */

// Создаем promise для загрузки данных с сервера
const getData = (url) => {
    return new Promise((resolve, reject) => {
        // Создаем новый объект XMLHttpRequest
        const xhr = new XMLHttpRequest();

        // Устанавливаем обработчик для успешного завершения запроса
        xhr.onload = () => {
            if (xhr.status === 200) {
                // Возвращаем результат в состоянии fulfilled
                resolve(xhr.responseText);
            } else {
                // Возвращаем ошибку в состоянии rejected
                reject(new Error(`Ошибка загрузки данных: ${url}`));
            }
        };

        // Устанавливаем обработчик для ошибки запроса
        xhr.onerror = () => {
            reject(new Error(`Ошибка сети: ${url}`));
        };

        // Отправляем запрос на сервер
        xhr.open("GET", url);
        xhr.send();
    });
};

// Создаем массив из нескольких URL-адресов, с которых нужно загрузить данные
const urls = ["/data1", "/data2", "/data3"];

// Используем Promise.all для одновременной загрузки данных
Promise.all(urls.map(getData))
    .then((results) => {
        // Выводим результаты на экран
        console.log(results);
    })
    .catch((error) => {
        // Обрабатываем ошибку
        console.error(error);
    });

/*
    В этом примере мы создаем массив из нескольких URL-адресов, с которых нужно загрузить данные.
    Затем мы используем Promise.all для одновременной загрузки данных:
    метод Promise.all принимает массив из нескольких promises и возвращает новый promise, который будет выполнен,
    когда все promises из массива будут выполнены.
    Затем мы используем метод then для вывода результатов на экран или метод catch для обработки ошибки.

    //___________________________________________________________________________________________________________________
    Promise.race
    В этом примере мы будем использовать Promise.race для выполнения задачи с использованием наиболее быстрого из доступных методов.
 */

// Создаем promise для задачи 1
const task1 = new Promise((resolve, reject) => {
    // Выполняем задачу 1 через 2 секунды
    setTimeout(() => {
        resolve("Задача 1 выполнена");
    }, 2000);
});

// Создаем promise для задачи 2
const task2 = new Promise((resolve, reject) => {
    // Выполняем задачу 2 через 3 секунды
    setTimeout(() => {
        resolve("Задача 2 выполнена");
    }, 3000);
});

// Создаем promise для задачи 3
const task3 = new Promise((resolve, reject) => {
    // Выполняем задачу 3 через 1 секунду
    setTimeout(() => {
        resolve("Задача 3 выполнена");
    }, 1000);
});

// Используем Promise.race для выполнения задачи с использованием наиболее быстрого из доступных методов
Promise.race([task1, task2, task3])
    .then((result) => {
        // Выводим результат на экран
        console.log(result);
    })
    .catch((error) => {
        // Обрабатываем ошибку
        console.error(error);
    });

/*
    В этом примере мы создаем три promises для трех задач с разным временем выполнения.
    Затем мы используем Promise.race для выполнения задачи с использованием наиболее быстрого из доступных методов:
    метод Promise.race принимает массив из нескольких promises и возвращает новый promise, который будет выполнен,
    когда любой из promises из массива будет выполнен. Затем мы используем метод then для вывода результата на экран
    или метод catch для обработки ошибки.
 */

//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
/*
    домашнее задание


    Задача 1
    Создайте простой promise, который выполняет асинхронную операцию (просто задержку на 2 секунды).
    Затем используйте метод then для обработки успешного выполнения операции и метод catch для обработки ошибок.
*/

// Создаем promise
const myPromise = new Promise((resolve, reject) => {
    // Выполняем асинхронную операцию
    setTimeout(() => {
        resolve("Успех!"); // Вызываем resolve, если операция завершена успешно
        //reject(new Error('Ошибка!')); // Вызываем reject, если операция завершена с ошибкой
    }, 2000);
});

// Используем метод then для обработки успешного выполнения операции
myPromise
    .then((result) => {
        console.log(result);
    })
    // Используем метод catch для обработки ошибок
    .catch((error) => {
        console.error(error);
    });

/*
    Задача 2
    https://jsonplaceholder.typicode.com
    Создайте два promises:
    первый для получения списка пользователей,
    а второй для получения постов пользователя по его ID.

    Затем используйте метод then для цепочки promises:
    после успешного выполнения первого promise получите ID первого пользователя из списка и передайте его
    второму promise для получения постов пользователя.
    Затем используйте метод then для вывода списка постов на экран и метод catch для обработки ошибок.
*/

// Создаем promise для получения списка пользователей
const getUsers = () => {
    return new Promise((resolve, reject) => {
        // Выполняем запрос к API
        fetch("https://jsonplaceholder.typicode.com/users")
            .then((response) => {
                if (response.ok) {
                    resolve(response.json());
                } else {
                    reject(new Error(`Ошибка получения списка пользователей: ${response.status}`));
                }
            })
            .catch((error) => reject(new Error(`Ошибка получения списка пользователей: ${error}`)));
    });
};

// Создаем promise для получения постов пользователя по его ID
const getPosts = (userId) => {
    return new Promise((resolve, reject) => {
        // Выполняем запрос к API
        fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`)
            .then((response) => {
                if (response.ok) {
                    resolve(response.json());
                } else {
                    reject(new Error(`Ошибка получения постов пользователя: ${response.status}`));
                }
            })
            .catch((error) => reject(new Error(`Ошибка получения постов пользователя: ${error}`)));
    });
};

// Получаем список пользователей и используем метод then для обработки успешного выполнения операции
getUsers()
    .then((users) => {
        // Получаем посты первого пользователя из списка
        const userId = users[0].id;
        return getPosts(userId);
    })
    .then((posts) => {
        // Выводим список постов на экран
        console.log(posts);
    })
    // Используем метод catch для обработки ошибок
    .catch((error) => {
        console.error(error);
    });

/*
    Задача 3
    Создайте три promises для трех задач с разным временем выполнения.
    Затем используйте метод Promise.race для выполнения задачи с использованием наиболее быстрого из доступных методов:
    метод Promise.race принимает массив из нескольких promises и возвращает новый promise, который будет выполнен,
    когда любой из promises из массива будет выполнен.
    Затем используйте метод then для вывода результата на экран или метод catch для обработки ошибки.
 */

// Создаем promises для трех задач с разным временем выполнения
const promise1 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Задача 1"), 3000);
});
const promise2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Задача 2"), 2000);
});
const promise3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve("Задача 3"), 1000);
});

// Используем Promise.race для выполнения задачи с использованием наиболее быстрого из доступных методов
Promise.race([promise1, promise2, promise3])
    // Используем метод then для вывода результата на экран
    .then((result) => {
        console.log(result);
    })
    // Используем метод catch для обработки ошибок
    .catch((error) => {
        console.error(error);
    });
