/*
    React - это библиотека JavaScript для создания пользовательских интерфейсов,
    которая позволяет разработчикам создавать переиспользуемые компоненты.
    Однако, создание крупных приложений может столкнуться с проблемами производительности.
    В этом материале мы рассмотрим несколько методов оптимизации React приложений, а также инструменты для тестирования и отладки.

    Оптимизация производительности React приложения
    Использование PureComponent

    React компоненты могут быть обычными компонентами, которые всегда перерисовываются при изменении свойств или состояния,
    или PureComponent, которые перерисовываются только при изменении свойств или состояния.
    Использование PureComponent может улучшить производительность приложения.

    Пример:
 */
import React, { PureComponent } from 'react';

class MyComponent extends PureComponent {
    render() {
        return <div>{this.props.text}</div>;
    }
}

/*
    Если вы не можете использовать PureComponent, вы можете определить метод shouldComponentUpdate, который решает,
    нужно ли перерисовывать компонент.

    Пример:
 */

import React, { Component } from 'react';

class MyComponent extends Component {
    shouldComponentUpdate(nextProps, nextState) {
        return nextProps.text !== this.props.text;
    }

    render() {
        return <div>{this.props.text}</div>;
    }
}

/*
     Использование ключей

    React использует ключи для определения того, какие элементы должны быть обновлены,
    добавлены или удалены при перерисовке компонентов.
    Если вы не зададите ключи явно, React будет использовать индексы массива, что может привести к проблемам производительности.
    Используйте уникальные ключи для каждого элемента массива.

    Пример:
 */

import React from 'react';

function MyList(props) {
    const items = props.items.map(item => (
        <li key={item.id}>{item.text}</li>
    ));

    return <ul>{items}</ul>;
}

/*
     Использование React.memo

    React.memo - это компонент-обертка, которая запоминает результат последнего рендеринга
    и повторно рендерит компонент только при изменении свойств.

    Пример:
 */

import React, { memo } from 'react';

const MyComponent = memo(props => {
    return <div>{props.text}</div>;
});

/*
    Работа с React DevTools для отладки и оптимизации кода
    React DevTools - это расширение для браузера, которое позволяет исследовать и отлаживать React компоненты.
    Оно предоставляет множество инструментов, таких как компонентное дерево, инспектор свойств и профилировщик производительности.
    Рассмотрим эти инструменты подробнее.


    Компонентное дерево

    Компонентное дерево позволяет визуально исследовать иерархию компонентов в приложении.
    Вы можете раскрывать и сворачивать узлы, чтобы изучить структуру приложения.
    Кроме того, вы можете изменять свойства компонентов непосредственно в DevTools и смотреть, как это влияет на приложение.


    Инспектор свойств

    Инспектор свойств позволяет просматривать свойства компонентов и изменять их значения.
    Вы также можете отслеживать изменения свойств в режиме реального времени, что помогает при отладке и оптимизации приложения.




    Профилировщик производительности

    Профилировщик производительности позволяет измерять производительность приложения и искать проблемы производительности.
    Вы можете записывать профили производительности и анализировать их в DevTools.
    Вы можете найти узкие места в приложении и оптимизировать его для улучшения производительности.




    Тестирование компонентов и приложения с помощью Jest и Enzyme
    Jest и Enzyme - это инструменты для тестирования React приложений.
    Jest - это фреймворк для тестирования JavaScript, который обеспечивает множество встроенных функций для тестирования.
    Enzyme - это библиотека, которая предоставляет дополнительные инструменты для тестирования React компонентов.





    Установка Jest и Enzyme

    Для начала установите Jest и Enzyme с помощью npm.

    // npm install jest enzyme enzyme-adapter-react-16 --save-dev



    Написание тестов

    Напишем тест для компонента:
 */


import React from 'react';
import { shallow } from 'enzyme';
import MyComponent from './MyComponent';

describe('MyComponent', () => {
    it('renders correctly', () => {
        const wrapper = shallow(<MyComponent text="Hello, world!" />);
        expect(wrapper).toMatchSnapshot();
    });
});

/*
    В этом тесте мы используем функцию shallow из Enzyme для создания экземпляра компонента MyComponent.
    Затем мы сравниваем его с снимком экрана с помощью функции toMatchSnapshot из Jest.
    Это позволяет легко обнаруживать изменения в компоненте, когда он меняется.




    Запуск тестов

    Вы можете запустить тесты с помощью команды: npm test

    Эта команда запускает все тесты, которые находятся в папке __tests__ в вашем проекте. Jest автоматически найдет все тесты и выполнит их.





    Оптимизация производительности React приложения
    Существует множество способов оптимизации производительности React приложения. Рассмотрим некоторые из них.

    Мемоизация компонентов

    Мемоизация - это процесс сохранения результата выполнения функции и возвращения его при повторном вызове функции с теми же параметрами.
    В React вы можете использовать мемоизацию для оптимизации компонентов, которые имеют дорогостоящий рендеринг.
    Для этого вы можете использовать функцию React.memo.
 */

import React from 'react';

const MyComponent = React.memo((props) => {
    /* Компонентная логика */
});

export default MyComponent;

/*
    Этот компонент будет перерисовываться только тогда, когда изменятся его свойства.
    Если свойства не изменились, компонент будет использовать сохраненный результат выполнения функции.

    Использование shouldComponentUpdate

    Метод shouldComponentUpdate позволяет контролировать,
    должен ли компонент обновляться или нет.
    Это может улучшить производительность приложения, если вы используете его правильно.
 */

import React from 'react';

class MyComponent extends React.Component {
    shouldComponentUpdate(nextProps) {
        /* Проверка, нужно ли обновлять компонент */
        return true;
    }

    render() {
        /* Компонентная логика */
    }
}

export default MyComponent;


/*
    Использование React.PureComponent

    React.PureComponent - это компонент, который реализует shouldComponentUpdate автоматически,
    сравнивая новые свойства и состояния с предыдущими. Если они не изменились, компонент не будет обновляться.
 */

import React from 'react';

class MyComponent extends React.PureComponent {
    render() {
        /* Компонентная логика */
    }
}

export default MyComponent;

/*
    Использование lazy и Suspense

    Lazy и Suspense позволяют отложить загрузку компонентов, что может существенно ускорить инициализацию приложения.
 */

import React, { lazy, Suspense } from 'react';

const MyComponent = lazy(() => import('./MyComponent'));

function App() {
    return (
        <div>
            <Suspense fallback={<div>Loading...</div>}>
                <MyComponent />
            </Suspense>
        </div>
    );
}

/*
    Этот код отложит загрузку компонента MyComponent до тех пор, пока он не будет запрошен.
    Если компонент не загружен, будет отображаться компонент-заглушка <div>Loading...</div>.
    Suspense может использоваться не только для отложенной загрузки компонентов, но и для отложенной загрузки данных или ресурсов.



    Использование мемоизированных селекторов

    Мемоизированные селекторы (memoized selectors) позволяют кэшировать результаты сложных вычислений,
    чтобы не пересчитывать их каждый раз, когда происходит обновление компонента.
 */


import { createSelector } from 'reselect';

const selectData = state => state.data;
const selectFilter = state => state.filter;

export const filteredDataSelector = createSelector(
    selectData,
    selectFilter,
    (data, filter) => {
        /* Сложная логика фильтрации и сортировки */
        return filteredData;
    }
);

/*
    Этот селектор будет пересчитываться только тогда, когда изменятся его зависимости - состояние data или filter.



    React предоставляет множество инструментов для оптимизации производительности и отладки приложения.
    React DevTools позволяет исследовать компоненты и их состояние, а Jest и Enzyme - тестировать компоненты и приложение.
    Мемоизация компонентов, использование shouldComponentUpdate, React.PureComponent и Suspense
    также могут помочь улучшить производительность приложения.
    Наконец, мемоизированные селекторы позволяют кэшировать результаты сложных вычислений и уменьшить количество пересчетов.
 */


//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
/*
    домашнее задание


    Написать компонент React, который отображает список элементов и позволяет их фильтровать по введенному пользователем тексту.
    Компонент должен принимать массив элементов в качестве пропсов и обрабатывать ввод пользователя с помощью управляемого компонента <input>.

*/

import { useState } from 'react';

function FilteredList({ items }) {
    const [filter, setFilter] = useState('');

    const filteredItems = items.filter((item) =>
        item.toLowerCase().includes(filter.toLowerCase())
    );

    const handleChange = (event) => {
        setFilter(event.target.value);
    };

    return (
        <div>
            <input type="text" value={filter} onChange={handleChange} />
            <ul>
                {filteredItems.map((item) => (
                    <li key={item}>{item}</li>
                ))}
            </ul>
        </div>
    );
}

/*
    Компонент FilteredList принимает массив items и отображает его в виде списка.
    Пользователь может фильтровать элементы, вводя текст в <input>.
    Каждый раз, когда пользователь вводит текст, вызывается обработчик handleChange,
    который устанавливает новое значение фильтра в состоянии компонента.
    Затем выполняется фильтрация элементов с помощью метода filter(),
    который создает новый массив только с теми элементами, которые удовлетворяют условию в переданной ему функции.
 */
