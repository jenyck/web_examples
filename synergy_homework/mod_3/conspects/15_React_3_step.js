/*
    Что такое компоненты высшего порядка
    Компоненты высшего порядка (Higher Order Components, HOC) в React -
    это функции, которые принимают компонент и возвращают новый компонент.
    Они являются одним из способов повторного использования логики компонентов в React.

    HOC позволяют вынести общую логику, которая может быть использована множеством компонентов в одном месте.
    Они могут быть использованы для логики аутентификации, логирования, обработки ошибок и других задач,
    которые могут быть общими для многих компонентов.

    Создание и использование компонентов высшего порядка
    Для создания компонента высшего порядка в React, необходимо создать функцию,
    которая принимает компонент в качестве аргумента и возвращает новый компонент.
    Например, следующий компонент высшего порядка обернет переданный ему компонент в div:
 */

function withDiv(Component) {
    return function (props) {
        return (
            <div>
                <Component {...props} />
            </div>
        );
    };
}

/*
    Здесь мы определили функцию withDiv, которая принимает компонент Component в качестве аргумента и возвращает новую функцию,
    которая принимает props и возвращает компонент Component, обернутый в div.

    Для использования компонента высшего порядка, его необходимо вызвать и передать ему компонент,
    который необходимо обернуть. Например, следующий код использует компонент withDiv, чтобы обернуть MyComponent в div:
 */

const WrappedComponent = withDiv(MyComponent);

/*
    Теперь WrappedComponent - это новый компонент, который включает MyComponent, обернутый в div.



    Применение компонентов высшего порядка для улучшения кода и повторного использования
    Компоненты высшего порядка позволяют повторно использовать общую логику компонентов в разных местах приложения,
    что приводит к более чистому и легкому для понимания коду.
    Они также позволяют избежать дублирования кода и уменьшить количество ошибок в приложении.

    Например, следующий компонент высшего порядка используется для проверки, авторизован ли пользователь, и если да,
    то отображает переданный ему компонент, а если нет, то отображает сообщение об ошибке:
 */

function withAuthorization(Component) {
    return function (props) {
        const isAuthenticated = checkAuth(); // Функция, которая проверяет, авторизован ли пользователь
        if (isAuthenticated) return <Component {...props} />;
        else return <div>Ошибка: пользователь не авторизован</div>;
    };
}

/*
    Здесь мы определили функцию `withAuthorization`, которая принимает компонент `Component` в качестве аргумента и возвращает новую функцию,
    которая проверяет, авторизован ли пользователь, используя функцию `checkAuth()`.
    Если пользователь авторизован, то возвращается компонент `Component`, в противном случае возвращается div с сообщением об ошибке.

    Для использования этого компонента высшего порядка, его можно вызвать и передать ему компонент,
    который необходимо проверить на авторизацию. Например, следующий код использует компонент `withAuthorization`,
    чтобы проверить, авторизован ли пользователь для отображения компонента `MyComponent`:
 */

const AuthenticatedComponent = withAuthorization(MyComponent);

/*
    Теперь AuthenticatedComponent - это новый компонент, который содержит логику проверки на авторизацию,
    и может быть использован в разных местах приложения.

    Компоненты высшего порядка также могут использоваться для повышения производительности приложения.
    Например, следующий компонент высшего порядка используется для кэширования данных
    и повторного использования их при повторном рендеринге:
 */

function withData(Component) {
    return class extends React.Component {
        constructor(props) {
            super(props);
            this.state = { data: null };
        }

        componentDidMount() {
            fetchData().then((data) => this.setState({ data }));
        }

        render() {
            return <Component data={this.state.data} {...this.props} />;
        }
    };
}

/*
    Здесь мы определили функцию withData, которая принимает компонент Component в качестве аргумента и возвращает новый компонент,
    который получает данные с помощью функции fetchData() при монтировании компонента и сохраняет их в состоянии.
    При повторном рендеринге компонента данные уже будут кэшированы и повторно использованы.

    Для использования этого компонента высшего порядка, его можно вызвать и передать ему компонент,
    который необходимо загрузить данные. Например, следующий код использует компонент withData,
    чтобы загрузить данные для компонента MyComponent:
 */

const DataComponent = withData(MyComponent);

/*
    Теперь DataComponent - это новый компонент, который загружает данные и кэширует их для повторного использования при повторном рендеринге.

    Важно заметить, что использование слишком многих компонентов высшего порядка может усложнить код и ухудшить его читаемость,
    поэтому нужно использовать их с умом и только там где это необходимо.

    Кроме того, компоненты высшего порядка могут иметь влияние на передачу свойств компоненту, который они оборачивают.
    Например, если компонент высшего порядка добавляет свойства в компонент, который он оборачивает,
    то это может привести к изменению интерфейса компонента и повлиять на его использование в других частях приложения.

    Также стоит учитывать, что компоненты высшего порядка могут быть заменены другими подходами, например, render props или Hooks.
    В зависимости от контекста и задач,
    иногда использование render props или Hooks может быть более удобным и эффективным способом работы с повторно используемым кодом.

    Ниже приведены дополнительные примеры кода с комментариями на русском языке, которые иллюстрируют использование компонентов высшего порядка в React.

    Пример 1: Компонент высшего порядка для логирования событий
 */

function withLogger(Component) {
    return class extends React.Component {
        componentDidMount() {
            console.log(`Компонент ${Component.name} был отображен`);
        }

        componentWillUnmount() {
            console.log(`Компонент ${Component.name} был удален`);
        }

        render() {
            return <Component {...this.props} />;
        }
    };
}

/*
    Этот компонент высшего порядка добавляет логирование событий жизненного цикла компонента, таких как монтирование и удаление.
    Для использования этого компонента высшего порядка, его можно вызвать и передать ему компонент, который необходимо логировать:
 */

const LoggedComponent = withLogger(MyComponent);

/*
    Пример 2: Компонент высшего порядка для управления состоянием формы
 */

function withForm(Component) {
    return class extends React.Component {
        constructor(props) {
            super(props);
            this.state = { formData: {} };
            this.handleFormChange = this.handleFormChange.bind(this);
            this.handleFormSubmit = this.handleFormSubmit.bind(this);
        }

        handleFormChange(event) {
            const target = event.target;
            const value = target.type === "checkbox" ? target.checked : target.value;
            const name = target.name;

            this.setState((prevState) => ({
                formData: { ...prevState.formData, [name]: value },
            }));
        }

        handleFormSubmit(event) {
            event.preventDefault();
            const formData = this.state.formData;
            // ... отправка данных формы на сервер
        }

        render() {
            return (
                <Component
                    formData={this.state.formData}
                    onFormChange={this.handleFormChange}
                    onFormSubmit={this.handleFormSubmit}
                    {...this.props}
                />
            );
        }
    };
}

/*
    Этот компонент высшего порядка добавляет управление состоянием формы и передает его через свойства компоненту, который он оборачивает.
    Для использования этого компонента высшего порядка, его можно вызвать и передать ему компонент формы:
 */

const FormWithState = withForm(MyFormComponent);

/*
    Затем компонент формы MyFormComponent получит состояние формы и методы для изменения состояния через свойства formData,
    onFormChange и onFormSubmit. Таким образом, мы можем сосредоточиться на логике компонента формы,
    не беспокоясь о деталях управления ее состоянием.

    Пример 3: Компонент высшего порядка для обработки ошибок
 */

function withErrorHandling(Component) {
    return class extends React.Component {
        constructor(props) {
            super(props);
            this.state = { error: null };
        }

        componentDidCatch(error, info) {
            console.log("Произошла ошибка:", error, info);
            this.setState({ error });
        }

        render() {
            if (this.state.error) {
                return <div>Произошла ошибка: {this.state.error.message}</div>;
            }

            return <Component {...this.props} />;
        }
    };
}

/*
    Этот компонент высшего порядка добавляет обработку ошибок в компонент, который он оборачивает.
    Если происходит ошибка при рендеринге компонента, componentDidCatch метод перехватывает ошибку и обновляет состояние компонента.
    Затем компонент выводит сообщение об ошибке вместо обычного содержимого, которое должно было быть отображено.

    Для использования этого компонента высшего порядка, его можно вызвать и передать ему компонент, который необходимо обработать:
 */

const ErrorHandledComponent = withErrorHandling(MyComponent);

/*
    Таким образом, мы можем сосредоточиться на реализации логики компонента,
    а компонент высшего порядка обрабатывает ошибки, которые могут возникнуть при его использовании.

    Компоненты высшего порядка - это мощный и гибкий способ улучшить повторное использование компонентов и избавиться от дублирования кода.
    Они позволяют нам создавать модульный, легко читаемый и расширяемый код,
    который может быть использован в различных контекстах и с разными компонентами.
    Однако следует использовать их с умом, чтобы избежать избыточности и усложнения кода.
 */

//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________
/*
    домашнее задание

    Задача 1
    Создайте компонент высшего порядка withLoading, который будет добавлять состояние загрузки и методы для управления им к любому компоненту.
    Когда компонент находится в состоянии загрузки, он должен отображать спиннер загрузки, а когда загрузка завершается,
    он должен отображать содержимое компонента. Используйте setTimeout для имитации загрузки данных.
*/

import React from "react";

function withLoading(Component) {
    return class extends React.Component {
        state = {
            loading: true,
        };

        componentDidMount() {
            setTimeout(() => {
                this.setState({ loading: false });
                // Имитация загрузки данных с задержкой в 3 секунды
                this.setState({ loading: false });
            }, 3000);
        }

        render() {
            const { loading } = this.state;
            return loading ? <div>Loading...</div> : <Component {...this.props} />;
        }
    };
}

/*
    Компонент высшего порядка `withLoading` принимает компонент `Component` и возвращает новый компонент,
    который добавляет состояние загрузки и отображает спиннер загрузки, пока данные загружаются.
    Когда данные загружены, он отображает содержимое компонента `Component`.
    Компонент высшего порядка использует метод жизненного цикла `componentDidMount` для имитации загрузки данных с помощью `setTimeout`.

    Задача 2
    Создайте компонент высшего порядка withToggle,
    который будет добавлять состояние переключателя и методы для управления им к любому компоненту.
    Когда переключатель находится включенном состоянии, он должен отображать определенный компонент,
    а когда он находится в выключенном состоянии, он должен отображать другой компонент.
    Используйте useState для хранения состояния переключателя.
 */

import React, { useState } from "react";

function withToggle(Component1, Component2) {
    return function (props) {
        const [toggle, setToggle] = useState(true);

        const handleToggle = () => {
            setToggle(!toggle);
        };

        const Component = toggle ? Component1 : Component2;

        return <Component {...props} toggle={toggle} onToggle={handleToggle} />;
    };
}

/*
    Компонент высшего порядка withToggle принимает два компонента Component1 и Component2 и возвращает новый компонент,
    который добавляет состояние переключателя и методы для управления им. Когда переключатель находится включенном состоянии,
    он отображает компонент Component1, а когда он находится в выключенном состоянии, он отображает компонент Component2.
    Компонент высшего порядка использует useState для хранения состояния переключателя и метод handleToggle,
    который меняет состояние переключателя.
 */
