/**

 Вложенные функции в JavaScript

 Пусть у нас есть функция, параметром принимающая два числа и возвращающая сумму квадратов этих чисел:

 function func(num1, num2) {
	return num1 * num1 + num2 * num2;
}

 console.log(func(2, 3)); // выведет 13 (результат 2 * 2 + 3 * 3)
 Давайте операцию возведения в квадрат вынесем в вспомогательную функцию square:

 function square(num) {
	return num * num;
}

 function func(num1, num2) {
	return square(num1) + square(num2);
}

 console.log(func(2, 3)); // выведет 13
 Пусть мы уверены, что функция square будет использоваться только в функции func и больше ни в какой другой.

 В этом случае было бы удобно сделать так, чтобы ее никто случайно не использовал (вы сами или другой программист, работающий вместе с вами).

 В JavaScript есть изящное решение: можно нашу вспомогательную функцию square поместить вовнутрь func.
 В этом случае наша вспомогательная функция будет доступна только внутри func, а снаружи - не будет.

 Сделаем это:

 function func(num1, num2) {
	function square(num) {
		return num * num;
	}

	return square(num1) + square(num2);
}

 console.log(func(2, 3)); // выведет 13
 Попытка вызвать square снаружи func приведет к ошибке:

 function func(num1, num2) {
	function square(num) {
		return num * num;
	}

	return square(num1) + square(num2);
}

 console.log(square(2)); // выдаст ошибку



 Если функция содержит внутри другую функцию - переменные внешней функции видны во внутренней:

 function test() {
	let num = 1; // переменная внешней функции

	function func() {
		console.log(num); // выведет 1
	}

	func(); // вызываем внутреннюю функцию
}

 test(); // вызываем внешнюю функцию
 Также во внутренней функции будут видны переменные, определенные снаружи внешней функции:

 let num = 1; // глобальная переменная

 function test() {
	function func() {
		console.log(num); // выведет 1
	}

	func(); // вызываем внутреннюю функцию
};

 test(); // вызываем внешнюю функцию


 Параметры внешней функции также будут доступны во внутренней:

 function test(num) {
	function func() {
		console.log(num); // выведет 1
	}

	func(); // вызываем внутреннюю функцию
};

 test(1); // передаем параметром число


 Давайте сделаем так, чтобы и внешняя функция и внутренняя принимали параметры:

 function test(num) {
	function func(localNum) {
		console.log(localNum);
	}
}
 Передадим параметр внешней функции в вызов внутренней функции:

 function test(num) {
	function func(localNum) {
		console.log(localNum); // выведет 1
	}

	func(num); // передаем параметр
}

 test(1); // передаем параметром число
 Получается, что во внутренней функции будет доступна переменная num как внешняя переменная из родительской функции и переменная localNum,
 являющаяся локальной переменной внутренней функции.

 Обе эти переменные будут иметь одинаковые значения:

 function test(num) {
	function func(localNum) {
		console.log(num); // выведет 1
		console.log(localNum); // выведет 1
	}

	func(num);
}

 test(1);
 Разница между ними будет в следующем: если во внутренней функции изменить переменную num - она поменяется и во внешней функции:

 function test(num) {
	function func(localNum) {
		num = 2; // меняем переменную num
	}

	func(num);   // передаем параметр
	console.log(num);  // выведет 2
}

 test(1); // передаем параметром число
 А переменная localNum будет локальной. Ее изменения не будут приводить ни к каким изменениям во внешней функции.
 Да и сама переменная localNum не будет видна снаружи внутренней функции:

 function test(num) {
	function func(localNum) {
		localNum = 2; // меняем переменную num
	}

	func(num); // передаем параметр
}

 test(1); // передаем параметром число


 Пусть теперь внешняя и внутренняя функция имеют одноименные параметры:

 function test(num) {
	function func(num) {
		console.log(num); // выведет 1
	}

	func(num);
};

 test(1);
 В этом случае во внутренней функции будет локальная переменная num.
 Ее изменение во внутренней функции никак не будет влиять на внешнюю переменную num:

 function test(num) {
	function func(num) {
		num = 2; // меняем локальную переменную num
	}

	func(num);
	console.log(num); // выведет 1 - ничего не поменялось
}

 test(1);
 Получится, что внутренняя функция никак не сможет обратиться к внешней переменной num для того, чтобы изменить ее:

 function test(num) {
	function func(num) {
		// тут нельзя получить доступ в внешней переменной num
	}

	func(num);
}
 test(1);



 Функции можно передавать параметрами в другие функции. Такие функции-параметры называются коллбэками (англ. callback).
 Давайте посмотрим работу с ними на примере.

 Пусть мы хотим сделать функцию, которая первым параметром будет принимать массив, а вторым - коллбэк, который будет
 применять к каждому элементу массива:

 function each(arr, callback) {
	// тут какой-то код
}
 Напишем реализацию нашей функции:

 function each(arr, callback) {
	let result = [];

	for (let elem of arr) {
		result.push( callback(elem) ); // вызываем функцию-коллбэк
	}

	return result;
}
 Наша функция each - универсальная. Это значит, что мы можем передавать в нее различные коллбэки, выполняя разные
 операции над массивами. При этом код нашей функции останется неизменным - будут меняться только передаваемые коллбэки.

 Давайте для примера с помощью нашей функции возведем в квадрат каждый элемент какого-нибудь массива.
 Для этого передадим параметром соответствующий коллбэк:

 let result = each([1, 2, 3, 4, 5], function(num) {
	return num ** 2;
});

 console.log(result);
 А теперь возведем элементы массива в куб. Для этого в качестве параметра передадим уже другой коллбэк, выполняющий эту операцию:

 let result = each([1, 2, 3, 4, 5], function(num) {
	return num ** 3;
});

 console.log(result);



 В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя. Давайте посмотрим на примере.
 Выведем с помощью рекурсии числа от 1 до 10:

 let i = 1;

 function func(){
	console.log(i);
	i++;

	if (i <= 10){
		func(); // здесь функция вызывает сама себя
	}
}
 func();
 Давайте обсудим, как работает этот код.

 У нас есть глобальная переменная i и функция func, внутри которой в консоль выводится содержимое переменной i, а затем делается ++.

 Если наша переменная i меньше или равна 10, то функция вызывается повторно. Так как переменная i - глобальная,
 то при каждом новом вызове функции в ней будет заданное при предыдущем вызове значение переменной i.

 Получится, что функция будет вызывать сама себя до тех пор, пока i не станет больше 10.

 Учтите, что в нашем случае нельзя функцию запустить без if - если это сделать, то получится бесконечный вызов функций.


 Давайте, с помощью рекурсии последовательно выведем элементы массива. Пусть массив изначально передается параметрам функции:

 func([1, 2, 3]);
 Давайте пока без рекурсии используя метод shift выведем все элементы массива по очереди:

 function func(arr) {
	console.log(arr.shift()); // выведет 1
	console.log(arr); // выведет [2, 3] - массив уменьшился

	console.log(arr.shift()); // выведет 2
	console.log(arr); // выведет [3] - массив уменьшился

	console.log(arr.shift()); // выведет 3
	console.log(arr); // выведет [] - массив пуст
}

 func([1, 2, 3]);
 Как вы видите, метод shift вырезает и возвращает первый элемент массива, при этом сам массив уменьшается на этот элемент.

 Давайте теперь используем рекурсию:

 function func(arr) {
	console.log(arr.shift(), arr);

	if (arr.length != 0) {
		func(arr);
	}
}

 func([1, 2, 3]);
 На самом деле, конечно же, проще всего перебрать элементы массива циклом.
 Приведенные примеры пока просто демонстрируют работу рекурсии на простых примерах (не жизненных).
 Более полезные примеры применения рекурсии просто более сложные, мы их разберем чуть ниже.


 Вспомним про многомерные массивы.

 Элементы массива могут быть не только строками и числами, но и массивами.
 В этом случае у нас получится массив массивов или многомерный массив.

 В следующем примере массив arr состоит из трех элементов, в свою очередь являющихся массивами:

 let arr = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']];
 Перепишем в более понятном виде:

 let arr = [
 ['a', 'b', 'c'],
 ['d', 'e', 'f'],
 ['g', 'h', 'i'],
 ];
 В зависимости от уровня вложенности массивы могут быть двухмерными - массив массивов, трехмерными - массив массивов
 массивов (ну и так далее - четырехмерными, пятимерными и тп).

 Приведенный выше массив является двухмерным, так как внутри одного массива расположены другие подмассивы и уже в
 этих подмассивах нет других массивов.

 Чтобы вывести какой-либо элемент из двухмерного массива следует писать уже не одну пару квадратных скобок, а две:

 let arr = [
 ['a', 'b', 'c'],
 ['d', 'e', 'f'],
 ['g', 'h', 'i'],
 ];

 console.log(arr[0][1]); // выведет 'b'
 console.log(arr[1][2]); // выведет 'f'


 Многомерные массивы не обязательно должны быть такими, как мы рассмотрели выше. Посмотрите, например, на следующий массив:

 let arr = [['a', 'b', [1, 2, 3], [4, 5]], ['d', ['e', 'f']]];
 Как вы видите, этот массив "неправильный". В нем рядом с обычными элементами (например, 'a', 'b')
 располагаются массивы ([1, 2, 3] и [4, 5]). Перепишем наш массив в более понятном виде:

 let arr = [
 [
 'a', 'b', [1, 2, 3], [4, 5],
 ],
 [
 'd', ['e', 'f'],
 ],
 ];


 Дан массив многомерный произвольного уровня вложенности, например, такой:

 let arr = [
 1,
 [
 2, 7, 8
 ],
 [
 3, 4, [5, [6, 7]],
 ]
 ];
 Как вы видите, данный массив имеет сложную структуру, причем предполагается, что эта структура может быть произвольной
 и уровни вложенности могут быть сколь угодно глубоко.

 Пусть мы хотим вывести в консоль все примитивные (то есть не массивы) элементы нашего массива.
 В этом случае для перебора такого массива у нас просто не получится использовать циклы,
 так как массив имеет неправильную структуру и неизвестный уровень вложенности.

 Зато для перебора такого массива очень удобно будет использовать рекурсию.

 Для начала сделаем функцию, в которую параметром будем передавать наш массив, а в функции сделаем цикл для перебора нашего массива:

 function func(arr) {
	for (let elem of arr) {
		console.log(elem);
	}
}

 func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);
 Сделанный нами цикл будет перебирать только элементы основного массива. То есть вначале он выведет 1,
 потом [2, 7, 8], а потом [3, 4, [5, [6, 7]].

 Давайте теперь будем разделять в цикле элементы-примитивы и элементы-массивы:

 function func(arr) {
	for (let elem of arr) {
		if (typeof elem == 'object') {
			// элемент - массив
		} else {
			// элемент - примитив
			console.log(elem);
		}
	}
}

 func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);
 А теперь сделаем так, чтобы если наш элемент - массив, функция вызывала сама себя, передавая параметром этот массив:

 function func(arr) {
	for (let elem of arr) {
		if (typeof elem == 'object') {
			func(elem);
		} else {
			console.log(elem);
		}
	}
}

 func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]);


 Давайте найдем сумму примитивных элементов нашего массива:

 function func(arr) {
	let sum = 0;

	for (let elem of arr) {
		if (typeof elem == 'object') {
			sum += func(elem);
		} else {
			sum += elem;
		}
	}

	return sum;
}

 console.log(func([1, [2, 7, 8], [3, 4, [5, [6, 7]]]]));

 _________________________________________________________________________________________________________________

 Итоги

 1 В программировании есть такое понятие, как рекурсия - это когда функция вызывает сама себя.

 2 Функции можно передавать параметрами в другие функции. Такие функции-параметры называются коллбэками (англ. callback)

 3 Элементы массива могут быть не только строками и числами, но и массивами. В этом случае у нас получится массив массивов
 или многомерный массив.

 4 Функция вложенная в функцию называется вложенной функцией

 5 Если функция содержит внутри другую функцию - переменные внешней функции видны во внутренней

 6 Функции можно передавать параметрами в другие функции. Такие функции-параметры называются коллбэками (англ. callback).
 _________________________________________________________________________________________________________________
 Домашняя работа

 1 Сделайте функцию func, которая параметрами будет принимать два числа,
 а возвращать сумму квадрата первого числа с кубом второго числа.
 Сделайте для этого вспомогательную функцию square, возводящую число в квадрат,
 и вспомогательную функцию cube, возводящую число в куб.

 2 let arr = [1, 2, 3, 4, 5];
 С помощью рекурсии найдите сумму квадратов элементов этого массива.

 3 let arr = [1, 2, 3, 4, 5];
 С помощью рекурсии найдите сумму квадратов элементов этого массива.
 Пример:
 function square(num) {
	return num ** 2;
}
 Давайте с ее помощью возведем каждый элемент массива в квадрат:

 function square(num) {
	return num * num;
}

 let result = each([1, 2, 3, 4, 5], square);
 console.log(result);

 **/
